#!/usr/bin/env ruby

BEGIN {
	require 'pathname'
	basedir = Pathname.new( __FILE__ ).expand_path.dirname.parent
	libdir = basedir + 'lib'

	$LOAD_PATH.unshift( libdir.to_s ) unless $LOAD_PATH.include?( libdir.to_s )
}


require 'thingfish'
require 'thingfish/client'
require 'uri'
require 'ipaddr'
require 'optparse'
require 'ostruct'


# thingfish - a command-line interface to ThingFish servers
#
# == Usage
#
#   $ thingfish OPTIONS COMMAND ARGS
#
# == Version
#
#  $Id$
#
#
class ThingFish::CommandLineClient
	include ThingFish::Constants,
		ThingFish::Loggable

	#################################################################
	###	C L A S S   M E T H O D S
	#################################################################

	### Get the options struct filled with defaults
	def self::get_default_options
		options = OpenStruct.new

		options.debug_mode = false
		options.verbose_mode = false
		options.profile_mode = false
		options.host = 'localhost'
		options.port = DEFAULT_PORT

		return options
	end


	### Given the specified +argv+, return a ostruct that describes the command-line options
	### that were parsed from it. This method can also exit on an invalid option specification
	### or when the '-h' option is given.
	def self::parse_options( argv )
		progname = Pathname.new( $0 ).basename
		opts = self.get_default_options

		oparser = OptionParser.new do |oparser|
			oparser.accept( Pathname ) {|path| Pathname.new(path) }

			oparser.banner = "Usage: #{progname.basename} OPTIONS ACTION [ARGS]"

			oparser.separator 'Actions:'
			oparser.separator '  upload, update, download, dump, check, info, search'

			oparser.separator ''
			oparser.separator 'Options:'
			oparser.on( '--host HOSTNAME', '-H', String,
				"Specify the host to connect to" ) do |hostname|
				opts.host = hostname
			end

			oparser.on( '--port PORTNUMBER', '-p', Integer,
				"Specify the port to connect to" ) do |hostname|
				opts.port = hostname
			end


			oparser.separator ''
			oparser.separator 'Other Options:'
			oparser.on( '--debug', '-d', FalseClass, "Turn on debugging" ) do
				$DEBUG = true
				$stderr.puts "Debugging enabled."
				opts.debugmode = true
			end

			oparser.on( '--verbose', '-v', FalseClass, "Turn on verbose output" ) do
				opts.verbosemode = true
			end

			oparser.on( '--profile', FalseClass,
						"Turn on server profiling (must also be enabled server side)" ) do
				opts.profilemode = true
			end

			oparser.on_tail( '--help', '-h', FalseClass, "Display help for the given command." ) do
				opts.helpmode = true
	        end

			# Another typical switch to print the version.
			oparser.on_tail( '--version', '-V', "Show ThingFish version" ) do
				$stderr.puts ThingFish.version_string( true )
				exit!
			end
		end

		remaining_args = oparser.parse( argv )
		if remaining_args.empty?
			$stderr.puts( oparser )
			exit( opts.helpmode ? 0 : 64 ) # EX_USAGE
		end

		return opts, *remaining_args
	end


	#################################################################
	###	I N S T A N C E   M E T H O D S
	#################################################################

	### Create a new ThingFish::CommandLineClient
	def initialize( options )
		@options = options

		uri = URI.parse( "http://%s:%d/" % [@options.host, @options.port] )
		@client = ThingFish::Client.new( uri, :profile => @options.profilemode )

		if @options.debugmode
			ThingFish.reset_logger
			ThingFish.logger.level = Logger::DEBUG
		elsif @options.verbosemode
			ThingFish.reset_logger
			ThingFish.logger.level = Logger::INFO
		end
	end


	######
	public
	######

	### Main logic
	def main( verb, *args )
		self.log.debug "Client requested '%s' with arguments: %p" % [ verb, args ]

		prefix = @options.helpmode ? 'help' : 'do'

		case verb.downcase
		when 'upload', 'post'
			return help_upload() if args.empty?
			send( "#{prefix}_upload", args.shift ) until args.empty?

		when 'update', 'put'
			return help_update() if (args.length % 2).nonzero? or args.empty?
			until args.empty?
				uuid = args.shift or raise "no UUID specified for update"
				file = args.shift
				send( "#{prefix}_update", uuid, file )
			end

		when 'download', 'get', 'fetch'
			return help_download() if args.empty?
			until args.empty?
				uuid = args.shift or raise "no UUID specified for fetch"
				file = args.shift
				send( "#{prefix}_download", uuid, file )
			end

		when 'check', 'head'
			return help_check() if args.empty?
			send( "#{prefix}_check", args.shift ) until args.empty?

		when 'search', 'find'
			return help_search() if (args.length % 2).nonzero? or args.empty?
			send( "#{prefix}_search", args )

		when 'dump'
			return help_dump() if args.empty?
			until args.empty?
				uuid = args.shift or raise "no UUID specified for dump"
				send( "#{prefix}_dump", uuid )
				$stdout.puts
			end

		when 'info'
			display_server_info()

		else
			raise "Don't know how to '#{verb}' yet."
		end
	end


	#########
	protected
	#########


	### Fetch the server info hash from the server and display it.
	def display_server_info
		info = @client.server_info or raise "couldn't fetch server info"

		handler_info = []
		filter_info  = []

		if @options.verbosemode
			max_length = info['handlers'].keys.max {|a,b| a.length <=> b.length }.length
			self.log.debug "Max length is: %d" % [max_length]
			info['handlers'].each do |name, hinfo|
				handler_info << "  %*s -> [ %s ]" % [ max_length, name, hinfo.join(', ') ]
			end

			info['filters'].each do |name, finfo|
				filter_info << "  %s v%s (rev %d)" % [
					name,
					finfo['version'].join('.'),
					finfo['rev']
				  ]
			end

		else
			handler_info << "  %p" % [ info['handlers'].keys.sort ]
			filter_info << "  %p" % [ info['filters'].keys.sort ]
		end

		$stdout.puts "%s is a version %s server." % [ @client.uri, info['version'] ],
			"Handlers: ",
			handler_info,
			"Filters: ",
			filter_info

	end


	### Upload the contents of the specified +file+ to the ThingFish at the given +uri+.
	### If +file+ is nil, the content will be read from STDIN instead.
	def do_upload( file=nil )
		fh = get_reader_io( file )
		resource = ThingFish::Resource.new( fh )
		resource.format = self.get_mimetype( file )

		if file
			resource.title  = File.basename( file )
			resource.extent = File.size( file )
		end

		@client.store( resource )

		$stderr.puts "Uploaded as '%s' to: %s" % [ resource.format, resource.uuid ]
	end


	### Output upload help to stderr.
	def help_upload( *args )
		self.print_help( 'upload <filename> [filename2] [filename3] ... ' )
	end


	### Update the resource at the specified +uuid+ on the ThingFish at the given +uri+
	### with the content from the specified +file+. If +file+ is nil, the content will
	### be read from STDIN instead.
	def do_update( uuid, file=nil )
		@client.has?( uuid ) or
			raise "No such resource #{uuid}"

		fh = get_reader_io( file )
		resource = ThingFish::Resource.new( fh, :client => @client, :uuid => uuid )
		resource.format = self.get_mimetype( file )

		if file
			resource.title  = File.basename( file )
			resource.extent = File.size( file )
		end

		resource.save

		$stderr.puts "Updated #{uuid}"
	end


	### Output update help to stderr.
	def help_update( *args )
		self.print_help( 'update <uuid> <filename> [<uuid2> <filename2>] ... ' )
	end


	### Verify that a resource with the specified +uuid+ exists on the ThingFish at
	### the given +uri+.
	def do_check( uuid )
		if @client.has?( uuid )
			$stderr.puts "%s has resource %s" % [ @client.uri, uuid ]
		else
			$stderr.puts "%s does NOT have resource %s" % [ @client.uri, uuid ]
		end
	end


	### Output check help to stderr.
	def help_check( *args )
		self.print_help( 'check <uuid> [uuid2] ... ' )
	end


	### Fetch the resource at the specified +uuid+ on the ThingFish at the given +uri+
	### and write it to the specified +file+. If +file+ is nil, the content will be
	### written to STDOUT instead.
	def do_download( uuid, file )
		resource = @client.fetch( uuid ) or
			raise "No such resource #{uuid}"

		fh = get_writer_io( file )
		resource.export( fh )
		fh.close

		$stderr.puts "Fetched resource at %s." % [ uuid ]
	end


	### Output download help to stderr.
	def help_download( *args )
		self.print_help( <<-EOH )
			download <uuid> <filename> [<uuid2> <filename2>] ...
			(Save resources to files on disk)
				
		EOH

		self.print_help( <<-EOH )
			download <uuid>
			(Stream a resource to stdout)			
		EOH
	end


	### Search for the provided terms at the server supplied 'simplesearch'
	### URL. Prints matching resource UUIDS and titles (if available) to stderr.
	def do_search( terms )
		terms = Hash[ *terms ]
		results = @client.find( terms )

		if results.empty?
			$stdout.puts "No resources were found that match your search terms."
			return
		end

		results.each do |resource|
			$stdout.puts "%s (%s)" % [ resource.uuid, resource.metadata[:title] ]
		end
	end


	### Output search help to stderr.
	def help_search( *args )
		self.print_help( 'search <property> <value> [<property2> <value2>] ...' )
	end


	### Fetch and display all metadata for a given +uuid+.
	def do_dump( uuid )
		metadata = @client.fetch_metadata( uuid )

		unless metadata
			$stdout.puts "No resources were found matching uuid #{uuid}."
			return
		end

		metadata.sort_by {|k,v| k.to_s}.each do |key, value|
			$stdout.puts "%20s --> %s" % [ key, value ]
		end
	end


	### Output upload help to stderr.
	def help_dump( *args )
		self.print_help( 'dump <uuid> [uuid2] [uuid3] ... ' )
	end


	### Get an IO object for reading from the specified +filename+. If +filename+ is
	### +nil+, returns the IO for STDIN instead.
	def get_reader_io( filename=nil )
		return $stdin unless filename
		return filename if filename.is_a?( File )
		return File.open( filename, File::RDONLY )
	end


	### Get an IO object for writing to the specified +filename+. If +filename+ is
	### +nil+, returns the IO for STDOUT instead.
	def get_writer_io( filename=nil )
		return $stdout unless filename
		return File.open( filename, File::WRONLY|File::CREAT|File::TRUNC )
	end


	# Create an object to deduce mimetypes.
	def get_mime_analyzer
		unless @mime_analyzer
			begin
				require 'mahoro'
				self.log.info "Using Mahoro for MIME analysis"
				flags = Mahoro::SYMLINK|Mahoro::MIME
				@mime_analyzer = Mahoro.new( flags )
			rescue LoadError
			end

			unless @mime_analyzer
				begin
					require 'filemagic'
					self.log.info "Using Filemagic for MIME analysis"
					flags = FileMagic::MAGIC_SYMLINK|FileMagic::MAGIC_MIME
					@mime_analyzer = FileMagic.new( flags )
				rescue LoadError
				end
			end

			unless @mime_analyzer
				self.log.info "Using mime map for mimetype analysis"
				@mime_analyzer = Class.new do
					def file( filename )
						ext = File.extname( filename )
						return MIMETYPE_MAP[ ext ] || 'application/octet-stream'
					end
					def buffer( ignored )
						return 'application/octet-stream'
					end
				end.new
			end

		end

		return @mime_analyzer
	end


	### Given a +file+, try to deduce a mimetype from the possible filename
	### extension.	Failing that, use the magic value to try to determine the
	### file's type if either the Mahoro or the filemagic library is installed.
	def get_mimetype( file )
		analyzer = self.get_mime_analyzer or
			raise "Ack. None of the strategies for deriving mimetype worked."

		if file.respond_to?( :read )
			io = self.get_reader_io( file )

			data = io.read( 2048 )
			io.rewind

			return analyzer.buffer( data )
		else
			return analyzer.file( file )
		end
	end


	### Print the given helptext with the program name after stripping leading
	### tabs.
	def print_help( helptext )
		$stderr.puts "%s %s" % [ $0, helptext.gsub(/^\t+/, '') ]
	end

end


begin
	opts, verb, *args = ThingFish::CommandLineClient.parse_options( ARGV )
	client = ThingFish::CommandLineClient.new( opts )

	client.main( verb, *args )

rescue => err
	$stderr.puts "ERROR: #{err.message}"
	$stderr.puts "  " + err.backtrace.join( "\n  " ) if $DEBUG
end

# vim: set nosta noet ts=4 sw=4:
