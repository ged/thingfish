---
title: "Connecting to the Server"
layout: default
index: 1
filters:
  - erb
  - examples
  - textile
---

h2. <%= page.config['title'] %>

There are several options for connecting: you can use a client library if one has
been written for your language, or you can use HTTP to talk to the server directly.

h3. The Basics

To test out the particulars of your connection, you can connect to the daemon with a
web browser by pointing it at the URL:

<pre>
http://your-thingfish-server:3474/
</pre>

It will (by default) display a page with documentation and a section describing each of the
configured handlers running on the server.

Because the server is extensible and overridable using plugins, the particulars of your server might
be different than the ones described here, but the basic upload/download REST API should remain
consistent.

h3. Operations

ThingFish exposes a REST-style API:


h4. Default Handler 

<dl class="apidocs kvlist">
	<dt>GET /</dt>
	<dd>
	  Fetch information about the server. The format of the information depends on the requested
	  type -- a @text/html@ request will display a server overview for web browsers, while
	  code-centric content types like @application/json@ and @text/x-yaml@ will return a serialized
	  hash of server information. This information can be later used to build REST queries to
	  access ThingFish's other services.

<?example { language: ruby, caption: "Server introspection hash" } ?>
{
	"version"=>"0.2.1",
	"filters" => {
		'filtername' => {
			"rev"       => 466,
			"accepts"   => [],
			"version"   => [1, 0],
			"supports"  => [],
			"generates" => ["mime/type"]},
		},
		# ... other filters
	},
	"handlers"=> {
		"handlername" => ["/uri1", "/uri2"],
		# ... other handlers
	}
}
<?end?>

	TODO: Document the particulars of what each part of the hash means.
	</dd>

	<dt>GET /«uuid»</dt>
	<dd>Return the data for a given file</dd>

	<dt>POST /</dt>
	<dd>Upload a file</dd>

	<dt>PUT /«uuid» </dt>
	<dd>Replace a file's data</dd>

	<dt>DELETE /«uuid» </dt>
	<dd>Delete a file from the datastore</dd>
</dl>


h4. Search Handler 

Returns a list of URIs for files which match the given search criteria.

<dl class="apidocs kvlist">
	<dt>GET /search?«querystring»</dt>
	<dd>Find files matching the criteria in the request's query string. The query string uses a 
		(somewhat) simple convention to build the logic of the search:</dd>

	<dd class="example">
		<p>(to be documented after the metastore changes are done)</p>
	</dd>
	
	<dt>POST /search</dt>
	<dd>This is a complex-query interface which allows you to perform more complex queries by
		passing the text of a structured query as the body of a POSTed request. The request's
		<code>Content-Type</code> header is used by the metastore to determine the format of 
		the request.</dd>
	<dd>For example, if you wanted to find a list of still images created by the same person in the
		same namespace as a given resource, and you were using the RDF metastore, you could
		submit an RDF+SPARQL query like so:</dd>
	<dd class="example">

	<pre><code>
	POST /search HTTP/1.1
	Content-type: application/sparql-query

	PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	PREFIX dc: <http://purl.org/dc/elements/1.1/>
	PREFIX dcmi: <http://dublincore.org/documents/dcmi-type-vocabulary/>
	PREFIX thingfish: <http://oss.laika.com/thingfish/rdf/2007/03/schema#>
	SELECT ?urn 
	WHERE  {
	    urn:uuid:c10b7ee8-cdad-11db-a110-23336f446aba dc:creator ?person
	    urn:uuid:c10b7ee8-cdad-11db-a110-23336f446aba thingfish:namespace ?ns
	    ?urn dc:creator ?person
	    ?urn dc:type dcmi:StillImage
	    ?urn thingfish:namespace ?ns
	}
	</code></pre>
	</dd>
</dl>


h4. Metadata Handler 

Returns a list of metadata tuples.

<dl class="apidocs kvlist">
	<dt>GET /metadata </dt>
	<dd>Return a list of all keys in the metastore</dd>

	<dt>GET /metadata/«uuid» </dt>
	<dd>Return a list of all metadata tuples for a given file</dd>

	<dt>GET /metadata/«key» </dt>
	<dd>Find all values in the store for the specified @key@.</dd>

	<dt>GET /metadata/«uuid»/«key» </dt>
	<dd>Find all values in the store for the specified @key@ for a given resource</dd>

	<dt>POST /metadata/«uuid» </dt>
	<dd>Upload new metadata values for the given file as a serialized data 
		structure in the entity body with the @Content-Type@ header set
		appropriately.</dd>

	<dt>POST /metadata/«uuid»/«key» </dt>
	<dd>Add a value for the given resource and @key@.</dd>

	<dt>PUT /metadata/«uuid»/«key» </dt>
	<dd>Replace the value for the given @key@ for the specified resource.</dd>

	<dt>DELETE /metadata/«uuid»</dt>
	<dd>Delete all non-protected metadata for the given file.</dd>

	<dt>DELETE /metadata/«uuid»/«key» </dt>
	<dd>Delete the values for the specified @key@ for the given resource</dd>
</dl>


h4. Admin Handler 

The admin handler is still unimplemented, so this interface will probably change when it's 
implemented. Some examples of what we're thinking:

<dl class="apidocs kvlist">
	<dt>GET /admin/diskspace</dt>
	<dd>Show available diskspace</dd>

	<dt>GET /admin/quotas </dt>
	<dd>Show and edit space/quotas per user</dd>

	<dt>GET /admin/cleanup </dt>
	<dd>Cleanup and maintenance (candidates for deletion?)</dd>

	<dt>GET /admin/status</dt>
	<dd>Show current usage (status, stats, and graphs -- rrd tool, IO, 
		trending performance)</dd>
</dl>



