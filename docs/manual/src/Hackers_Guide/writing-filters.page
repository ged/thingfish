---
title: "Writing a ThingFish Filter"
tagline: Thingfish. Filter dooo. goood.
layout: default
index: 3
filters:
  - erb
  - api
  - examples
  - textile
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

h3. How's a filter different than a handler?

For a given URI, a handler is what performs the actual response to the
client.  Filters are chainable code that has the opportunity to look at
and optionally modify both the request and the response, regardless of
URI.

We like to think of filters that operate on incoming data as
'extraction' filters, as they commonly pull more data out of uploaded
files for the metastore.  For example, detecting and storing id3
information for MP3 uploads.

Filters that operate on the response could be thought of as 'conversion'
filters, such as a filter designed to dynamically convert a TIFF file to
a JPEG via the client's @Accept@ header.


h3. What does a filter look like?

Great question!  Here's one that we'll use to point out some filtery
concepts.  This is the YAML filter that comes with ThingFish,
responsible for converting data structures to and from the
"YAML":http://www.yaml.org/ format.

<?example { language: ruby, caption: 'A minimal filter (that does nothing, yet.)' } ?>
require 'thingfish/constants'
require 'thingfish/filter'
require 'thingfish/acceptparam'
require 'yaml'

class ThingFish::YAMLFilter < ThingFish::Filter
	include ThingFish::Constants

	# SVN Revision (for the #info hash)
	SVNRev = %q$Rev: 620 $
	
	HANDLED_TYPES = [ ThingFish::AcceptParam.parse(RUBY_MIMETYPE) ]
	YAML_MIMETYPE = 'text/x-yaml'

	### Return an Array of ThingFish::AcceptParam objects which describe which content types
	### the filter is interested in. The default returns */*, which indicates that it is
	### interested in all requests/responses.
	def handled_types
		return HANDLED_TYPES
	end


	### Returns a Hash of information about the filter; this is of the form:
	###   {
	###       'version'  => [ 0, 60 ],          # YAML.rb version
	###       'supports' => [ [1,0], [1,1] ],   # Supported YAML versions
	###       'rev'      => 460                 # SVN rev of plugin
	###   }
 	def info
		yaml_rb_version = YAML::VERSION.split('.').collect {|i| Integer(i) }
		supported_yaml_version = YAML::SUPPORTED_YAML_VERSIONS.collect do |v|
			v.split('.').collect {|i| Integer(i) }
		end

		return {
			'version'  => yaml_rb_version,
			'supports' => supported_yaml_version,
			'rev'      => Integer( SVNRev[/\d+/] || 0 ),
			'accepts'   => [YAML_MIMETYPE],
			'generates' => [YAML_MIMETYPE]
		}
	end
end
<?end example?>

|_. line number |_. what's it doing? |
| 6 | All filters inherit from the <?api ThingFish::Filter ?> parent class.
The filter name needs to match the filename it is stored in -
in this case, the file would be called _yaml.rb_, and be stored in a _lib/filter_ directory. |
| 7 | Import some useful constants, such as mimetype defaults like @RUBY_MIMETYPE@. |
| 15 | All filters must specify what mimetypes they are interested in.  They do this via the
@handled_types@ method, which returns an array of <?api ThingFish::AcceptParam ?> objects.
The default is */*, which attaches this filter to all requests and responses. |
| 26 | All filters must define an @info@ method that provides introspection to the rest of ThingFish.
Clients can check what filters are installed on a ThingFish server via a GET request to @/@. |

h3. Installing the filter

At this point, we've got a no-op filter that needs an introduction
to ThingFish. This is done in the @thingfish.conf@ file, under the
@filters@ section.

<?example { language: yaml, caption: "Our filter's config section" } ?>
plugins:
    filters:
        - yaml
<?end example?>

And that's it!  If the filter has configurable options, you can add a
hash that will be passed to the filter's initializer:

<?example { language: yaml, caption: "Our filter's config with options" } ?>
plugins:
    filters:
        - yaml:
		      option1: value1
			  option2: value2
<?end example?>

h3. Extraction filters

Now that we've got a filter framework, we probably want our new filter
to actually perform an action of some sort.  Filters can operate on
requests (extraction filters), responses (conversion filters), or both.

<?example { language: ruby, caption: An example extraction filter. } ?>
require 'thingfish/constants'
require 'thingfish/filter'
require 'thingfish/acceptparam'
require 'yaml'

class ThingFish::YAMLFilter < ThingFish::Filter
	include ThingFish::Constants

	HANDLED_TYPES = [ ThingFish::AcceptParam.parse(RUBY_MIMETYPE) ]
	YAML_MIMETYPE = 'text/x-yaml'

	### ( #handled_types and #info removed for brevity )

	### Filter incoming requests, converting YAML to native ruby objects.
	def handle_request( request, response )

		# Only filter if the client sends what we can convert from.
		return unless request.content_type &&
			request.content_type.downcase == YAML_MIMETYPE

		request.body = YAML.load( request.body.read )
		request.content_type = RUBY_MIMETYPE
	end
end
<?end example?>

|_. line number |_. what's it doing? |
| 15 | Filters operate on the request by defining a @handle_request@ method.
This method receives a <?api ThingFish::Request ?> and a <?api ThingFish::Response ?> object 
to fiddle with as you see fit. |
| 17 | Since all filters in the chain have the opportunity to examine
the request as it passes by, it's a good idea to stop early if this
particular request isn't something you are interested in.  In this case,
we only care about requests that specify content in a YAML format. |
| 20 | Read in and convert the YAML body to a ruby data structure. |
| 21 | Tell the rest of the filter chain that the content is now ruby data. |

Where this filter is simply altering the incoming request data, it's
important to keep in mind that you can do __anything__ with the request
here. <?api ThingFish::Request ?> has a bunch of convenience methods to
help make things like multipart processing easy.  In addition to simple
data transformations, extraction filters are the perfect way to generate
automatic metadata about the request.


h4. Appending Metadata

Here's an example that parses id3 information from an uploaded mp3.

<?example { language: ruby, caption: An extraction filter that attaches metadata. } ?>
require 'thingfish'
require 'thingfish/filter'
require 'thingfish/constants'
require 'thingfish/acceptparam'
require 'mp3info'

class ThingFish::MP3Filter < ThingFish::Filter
	include ThingFish::Constants

	# SVN Revision (for the #info hash)
	SVNRev = %q$Rev: 620 $

	# The Array of types this filter is interested in
	HANDLED_TYPES = [ 'audio/mpeg', 'audio/mpg', 'audio/mp3' ].
		collect {|mimetype| ThingFish::AcceptParam.parse(mimetype) }

	### Extract metadata from incoming requests if their content-type headers
	### indicate its MP3 data.
	def handle_request( request, response )
		return unless request.http_method == :PUT ||
			request.http_method == :POST

		request.each_body do |body, metadata|
			if self.accept?( metadata[:format] )

				id3 = Mp3Info.new( body.path )
				mp3_metadata = self.extract_id3_metadata( id3 )

				request.append_metadata_for( body, mp3_metadata )
			end
		end
	end

	### Which content types the filter is interested in.
	def handled_types
		return HANDLED_TYPES
	end

	### Introspection information about the filter.
	def info
		accepts = self.handled_types.map {|ap| ap.mediatype }

		return {
			'version'   => [1,0],
			'supports'  => Mp3Info::VERSION.split('.'),
			'rev'       => Integer( SVNRev[/\d+/] || 0 ),
			'accepts'   => accepts,
			'generates' => [],
		  }
	end

	### Hand-wavey stub that uses the mp3Info module.
	def extract_id3_metadata( id3 ); end
end
<?end example?>


|_. line number |_. what's it doing? |
| 14 | Set the filter to accept MP3s by accepting the various mimetypes
in common use. |
| 20 | If the request isn't an upload of some kind, ignore it.
Returning just passes the request to the next filter in the chain. |
| 23 | Iterate over each resource in the request. This includes all the
parts of a multipart request body. |
| 24 | Skip any non-MP3 resources. The @#accept?@ method compares
the request's @Content-type@ header against the array of <?api
ThingFish::AcceptParam ?> objects returned by @#handled_types@ and
returns @true@ if there is at least one match. |
| 27 | Extract a hash of mp3 metadata from the Mp3Info object. |
| 29 | Append the extracted hash to the current body's metadata hash. |
| 43 | The filter info hash includes the Mp3Info module's version, the
revision of the filter itself, and an array of the mimetypes the filter
is interested in. |


The metadata yielded for each resource is a union of four sets of
key/value pairs, with each set overriding values from the previous:

* Any metadata extracted by (previous) filters
* Metadata passed in the request as query arguments (e.g., from an upload form)
* Content metadata that pertains to the body being yielded (e.g., content-type, content-length)
* Request metadata (e.g., user agent, requester's IP, etc.)


h4. Appending Related Resources

Filters can generate new resources and 'attach' them to the original
resource as a related entity.  Let's add a album art thumbnail to an
uploaded mp3 file.

<?example { language: ruby, caption: An extraction filter that attaches new resources. } ?>
require 'thingfish'
require 'thingfish/filter'
require 'thingfish/constants'
require 'thingfish/acceptparam'
require 'mp3info'

class ThingFish::MP3Filter < ThingFish::Filter
	include ThingFish::Constants

	# The Array of types this filter is interested in
	HANDLED_TYPES = [ 'audio/mpeg', 'audio/mpg', 'audio/mp3' ].
		collect {|mimetype| ThingFish::AcceptParam.parse(mimetype) }

	### Extract metadata from incoming requests if their content-type headers
	### indicate its MP3 data.
	def handle_request( request, response )
		return unless request.http_method == :PUT ||
			request.http_method == :POST

		request.each_body do |body, metadata|
			if self.accept?( metadata[:format] )

				id3 = Mp3Info.new( body.path )
				mp3_metadata = self.extract_id3_metadata( id3 )

				# Append any album images as related resources
				self.extract_images( id3 ).each do |io, metadata|
					metadata[:title] = "Album art for %s - %s" % mp3_metadata.values_at( :mp3_artist, :mp3_title )
					request.append_related_resource( body, io, metadata )
				end

				request.append_metadata_for( body, mp3_metadata )
			end
		end
	end

	### ( #handled_types and #info removed for brevity )

	### Hand-wavey stub that extracts album art from an mp3.
	def extract_images( id3 ); end
end
<?end example?>

|_. line number |_. what's it doing? |
| 27 | Create a new IO object from the extracted album artwork, along with metadata about the image. |
| 29 | Attach the @io@ with its specific @metadata@ to the parent @body@. |

New related resources that are created will receive two additional
metadata keys, linking them to their respective parent resources.

* relation: This marks the resource as being related to another
resource, and describes what that relationship is.  In the above
example, it could be 'thumbnail' or 'album-art' -- that's up to you.  If
you don't pick one, it defaults to the value 'appended'.
* related_to: This is set to the UUID of the parent resource.

h3. Conversion filters

Another thing that filters can do is convert outgoing content to (better) match the requested format type using the rules of HTTP content-negotiation. Conversion is handled by the @#handle_response@ method, which like @#handle_request@, is passed both the <?api ThingFish::Response ?> and the
<?api ThingFish::Request ?> for the current connection.

The filter should:

# Check to see if it can transform the response in a way that the client wants (i.e., the response is in a format that the client doesn't accept, or the filter can transform it to some format that the client prefers over the original)
# Transform the original body and replace it with the new one
# Make any necessary adjustments to the response headers

<?example { language: ruby, caption: A conversion filter for marshalled Ruby objects. } ?>
require 'thingfish/constants'
require 'thingfish/filter'
require 'thingfish/acceptparams'

class ThingFish::RubyFilter < ThingFish::Filter
	include ThingFish::Constants

	# SVN Revision (for the #info hash)
	SVNRev = %q$Rev: 620 $

	# The Array of types this filter is interested in
	HANDLED_TYPES = [ ThingFish::AcceptParam.parse(RUBY_MIMETYPE) ]

	### Marshal outgoing Ruby objects.
	def handle_response( response, request )
		# Only filter if the client wants what we can convert to, and the response body
		# is something we know how to convert
		return unless request.explicitly_accepts?( RUBY_MARSHALLED_MIMETYPE ) &&
			self.accept?( response.content_type )

		response.body = Marshal.dump( response.body )
		response.content_type = RUBY_MARSHALLED_MIMETYPE
	end


	### Which content types the filter is interested in.
	def handled_types
		return HANDLED_TYPES
	end

	### Introspection information about the filter.
	def info
		ruby_version = RUBY_VERSION.split('.').collect {|i| Integer(i) }
		supported_marshal_version = [[
			Marshal::MAJOR_VERSION,
			Marshal::MINOR_VERSION,
		  ]]
		mimetypes = self.handled_types.collect {|accept| accept.to_s }

		return {
			'version'   => ruby_version,
			'supports'  => supported_marshal_version,
			'rev'       => Integer( SVNRev[/\d+/] || 0 ),
			'accepts'   => mimetypes,
			'generates' => mimetypes,
		  }
	end
<?end example?>

|_. line number |_. what's it doing? |
| 29 | Attach the @io@ with its specific @metadata@ to the parent @body@. |


h3. Gotchas(?)

(Filters should be re-entrant -- requests should have dedicated workers instead of stuff in the initializer)
