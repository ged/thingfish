#!/usr/bin/env ruby
# 

BEGIN {
	require 'pathname'
	basedir = Pathname.new( __FILE__ ).expand_path.dirname.parent
	libdir = basedir + 'lib'
	
	$LOAD_PATH.unshift( libdir.to_s ) unless $LOAD_PATH.include?( libdir.to_s )
	require basedir + 'utils.rb'
	include UtilityFunctions
}


require 'thingfish'
require 'thingfish/client'
require 'uri'
require 'optparse'
require 'ostruct'


# thingfish - a command-line interface to ThingFish servers
# 
# == Usage
# 
#   $ thingfish OPTIONS COMMAND ARGS
# 
# == Version
#
#  $Id$
# 
# 
class ThingFish::CommandLineClient
	include ThingFish::Constants,
		ThingFish::Loggable

	#################################################################
	###	C L A S S   M E T H O D S
	#################################################################

	### Get the options struct filled with defaults
	def self::get_default_options
		options = OpenStruct.new

		options.debug_mode = false
		options.verbose_mode = false
		options.host = 'localhost'
		options.port = DEFAULT_PORT

		return options
	end


	### Given the specified +argv+, return a ostruct that describes the command-line options
	### that were parsed from it. This method can also exit on an invalid option specification
	### or when the '-h' option is given.
	def self::parse_options( argv )
		progname = Pathname.new( $0 ).basename
		opts = self.get_default_options

		oparser = OptionParser.new do |oparser|
			oparser.accept( Pathname ) {|path| Pathname.new(path) }

			oparser.banner = "Usage: #{progname.basename} OPTIONS ACTION [ARGS]"

			oparser.separator 'Actions:'
			oparser.separator '  upload, update, download, check, info'

			oparser.separator ''
			oparser.separator 'Options:'
			oparser.on( '--host HOSTNAME', '-H', String, 
				"Specify the host to connect to" ) do |hostname|
				opts.host = hostname
			end

			oparser.on( '--port PORTNUMBER', '-p', Integer,
				"Specify the port to connect to" ) do |hostname|
				opts.port = hostname
			end


			oparser.separator ''
			oparser.separator 'Other Options:'
			oparser.on( '--debug', '-d', FalseClass, "Turn on debugging" ) do
				$DEBUG = true
				$stderr.puts "Debugging enabled."
				opts.debugmode = true
			end

			oparser.on( '--verbose', '-v', FalseClass, "Turn on verbose output" ) do
				opts.verbosemode = true
			end

			oparser.on_tail( '--help', '-h', FalseClass, "Display this help." ) do
				$stderr.puts oparser
				exit!
	        end

			# Another typical switch to print the version.
			oparser.on_tail( '--version', '-V', "Show ThingFish version" ) do
				$stderr.puts ThingFish.version_string( true )
				exit!
			end
		end

		remaining_args = oparser.parse( argv )
		if remaining_args.empty?
			$stderr.puts( oparser )
			exit( 64 ) # EX_USAGE
		end

		return opts, *remaining_args
	end
	
	
	#################################################################
	###	I N S T A N C E   M E T H O D S
	#################################################################
	
	### Create a new ThingFish::CommandLineClient
	def initialize( options )
		uri = URI.parse( "http://%s:%d/" % [options.host, options.port] )
		@client = ThingFish::Client.new( uri )
		
		if options.debugmode
			ThingFish.reset_logger
			ThingFish.logger.level = Logger::DEBUG
		elsif options.verbosemode
			ThingFish.reset_logger
			ThingFish.logger.level = Logger::INFO
		end
	end
	
	
	######
	public
	######

	### Main logic
	def main( verb, *args )
		self.log.debug "Client requested '%s' with arguments: %p" % [ verb, args ]
	
		case verb.downcase
		when 'upload', 'post'
			do_upload( args.shift ) until args.empty?
	
		when 'update', 'put'
			until args.empty?
				uuid = args.shift or raise "no UUID specified for update"
				file = args.shift
				do_update( uuid, file )
			end
	
		when 'download', 'get', 'fetch'
			until args.empty?
				uuid = args.shift or raise "no UUID specified for fetch"
				file = args.shift
				do_download( uuid, file )
			end
	
		when 'check', 'head'
			do_check( args.shift ) until args.empty?
	
		when 'info'
			self.log.debug "Fetching server info"
			info = @client.server_info or raise "couldn't fetch server info"
			$stdout.puts "%s is a version %s server." % [ @client.uri, info['version'] ],
				"Handlers: ",
				"  %p" % [ info['handlers'].keys.sort ],
				"Filters: ",
				"  %p" % [ info['filters'].keys.sort ]
	
		else
			raise "Don't know how to '#{verb}' yet."
		end
	end


	#########
	protected
	#########


	### Upload the contents of the specified +file+ to the ThingFish at the given +uri+. 
	### If +file+ is nil, the content will be read from STDIN instead.
	def do_upload( file=nil )
		fh = get_reader_io( file )
		resource = ThingFish::Resource.new( fh )
		resource.format = self.get_mimetype( fh )

		if file
			resource.title  = File.basename( file )
			resource.extent = File.size( file )
		end

		@client.store( resource )
		
		$stderr.puts "Uploaded to: #{resource.uuid}"
	end


	### Update the resource at the specified +uuid+ on the ThingFish at the given +uri+
	### with the content from the specified +file+. If +file+ is nil, the content will
	### be read from STDIN instead.
	def do_update( uuid, file=nil )
		@client.has?( uuid ) or
			raise "No such resource #{uuid}"

		fh = get_reader_io( file )
		resource = ThingFish::Resource.new( fh, :client => @client, :uuid => uuid )
		resource.format = self.get_mimetype( file, fh )

		if file
			resource.title  = File.basename( file )
			resource.extent = File.size( file )
		end

		resource.save

		$stderr.puts "Updated #{uuid}"
	end


	### Verify that a resource with the specified +uuid+ exists on the ThingFish at 
	### the given +uri+.
	def do_check( uuid )
		if @client.has?( uuid )
			$stderr.puts "%s has resource %s" % [ @client.uri, uuid ]
		else
			$stderr.puts "%s does NOT have resource %s" % [ @client.uri, uuid ]
		end
	end
	

	### Fetch the resource at the specified +uuid+ on the ThingFish at the given +uri+
	### and write it to the specified +file+. If +file+ is nil, the content will be
	### written to STDOUT instead.
	def do_download( uuid, file )
		resource = @client.fetch( uuid ) or
			raise "No such resource #{uuid}"
			
		fh = get_writer_io( file )
		resource.export( fh )
		fh.close

		$stderr.puts "Fetched resource at %s." % [ uuid ]
	end


	### Get an IO object for reading from the specified +filename+. If +filename+ is 
	### +nil+, returns the IO for STDIN instead.
	def get_reader_io( filename=nil )
		return $stdin unless filename
		return filename if filename.is_a?( File )
		return File.open( filename, File::RDONLY )
	end


	### Get an IO object for writing to the specified +filename+. If +filename+ is 
	### +nil+, returns the IO for STDOUT instead.
	def get_writer_io( filename=nil )
		return $stdout unless filename
		return File.open( filename, File::WRONLY|File::CREAT|File::TRUNC )
	end


	# Create an object to deduce mimetypes.
	def get_mime_analyzer
		unless @mime_analyzer
			begin
				require 'mahoro'
				self.log.info "Using Mahoro for MIME analysis"
				flags = Mahoro::SYMLINK|Mahoro::MIME
				@mime_analyzer = Mahoro.new( flags )
			rescue LoadError
			end
	
			unless @mime_analyzer
				begin
					require 'filemagic'
					self.log.info "Using Filemagic for MIME analysis"
					flags = FileMagic::MAGIC_SYMLINK|FileMagic::MAGIC_MIME
					@mime_analyzer = FileMagic.new( flags )
				rescue LoadError
				end
			end
	
			unless @mime_analyzer
				self.log.info "Using mime map for mimetype analysis"
				@mime_analyzer = Class.new do
					def file( filename )
						ext = File.extname( filename )
						return MIMETYPE_MAP[ ext ] || 'application/octet-stream'
					end
					def buffer( ignored )
						return 'application/octet-stream'
					end
				end.new
			end

		end
		
		return @mime_analyzer
	end


	### Given a +file+ and an optional +io+, try to deduce a mimetype from the
	### possible filename extension.  Failing that, use the first 2k of data
	### read from the given +io+ and return it. The IO object will be rewound
	### before returning.
	def get_mimetype( file )
		analyzer = self.get_mime_analyzer or
			raise "Ack. None of the strategies for deriving mimetype worked."

		if file.respond_to?( :extname )
			return analyzer.file( file )
		else	
			io ||= self.get_reader_io( file )

			data = io.read( 2048 )
			io.rewind

			return analyzer.buffer( data )
		end
	end

end


if __FILE__ == $0
	begin
		opts, verb, *args = ThingFish::CommandLineClient.parse_options( ARGV )
		client = ThingFish::CommandLineClient.new( opts )

		client.main( verb, *args )

	rescue => err
		$stderr.puts "ERROR: #{err.message}"
		$stderr.puts "  " + err.backtrace.join( "\n  " ) if $DEBUG
	end
end

# vim: set nosta noet ts=4 sw=4:
