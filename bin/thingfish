#!/usr/bin/env ruby
# 
# thingfish - a command-line interface to ThingFish servers
# 
# == Usage
# 
#   $ thingfish URL upload FILE
#   $ thingfish URL check  UUID
#   $ thingfish URL fetch  UUID FILE
#   $ thingfish URL update UUID FILE
# 
# == Version
#
#  $Id$
# 
# 

BEGIN {
	require 'pathname'
	basedir = Pathname.new( __FILE__ ).expand_path.dirname.parent
	libdir = basedir + 'lib'
	
	$LOAD_PATH.unshift( libdir.to_s ) unless $LOAD_PATH.include?( libdir.to_s )
	require basedir + 'utils.rb'
	include UtilityFunctions
}


require 'thingfish'
require 'thingfish/client'
require 'uri'



class ThingFish::CommandLineClient
	
	### Create a new ThingFish::CommandLineClient
	def initialize
		@client = nil
	end
	
	
	######
	public
	######

	### Main logic
	def main( uri, verb, *args )
		@client = ThingFish::Client.new( uri )
	
		until args.empty?
			case verb
			when /^(upload|post)$/i
				file = args.shift
				do_upload( uri, file )
		
			when /^(update|put)$/i
				uuid = args.shift or raise "no UUID specified for update"
				file = args.shift
				do_update( uri, uuid, file )
		
			when /^(download|get|fetch)$/
				uuid = args.shift or raise "no UUID specified for fetch"
				file = args.shift
				do_download( uri, uuid, file )
		
			when /^(check|head|info)$/
				uuid = args.shift or raise "no UUID specified for check"
				do_check( uri, uuid )
		
			else
				raise "Don't know how to '#{verb}' yet."
			end
		end
	end


	#########
	protected
	#########


	### Upload the contents of the specified +file+ to the ThingFish at the given +uri+. 
	### If +file+ is nil, the content will be read from STDIN instead.
	def do_upload( uri, file=nil )
		fh = get_reader_io( file )
		resource = ThingFish::Resource.new( fh )
		resource.format = self.get_mimetype( fh )

		if file
			resource.title  = File.basename( file )
			resource.extent = File.size( file )
		end

		@client.store( resource )
		
		$stderr.puts "Uploaded to: #{resource.uuid}"
	end


	### Update the resource at the specified +uuid+ on the ThingFish at the given +uri+
	### with the content from the specified +file+. If +file+ is nil, the content will
	### be read from STDIN instead.
	def do_update( uri, uuid, file=nil )
		@client.has?( uuid ) or
			raise "No such resource #{uuid}"

		fh = get_reader_io( file )
		resource = ThingFish::Resource.new( fh, :client => @client, :uuid => uuid )
		resource.format = self.get_mimetype( fh )

		if file
			resource.title  = File.basename( file )
			resource.extent = File.size( file )
		end

		resource.save

		$stderr.puts "Updated #{uuid}"
	end


	### Verify that a resource with the specified +uuid+ exists on the ThingFish at 
	### the given +uri+.
	def do_check( uri, uuid )
		if @client.has?( uuid )
			$stderr.puts "%s has resource %s" % [ @client.uri, uuid ]
		else
			$stderr.puts "%s does NOT have resource %s" % [ @client.uri, uuid ]
		end
	end
	

	### Fetch the resource at the specified +uuid+ on the ThingFish at the given +uri+
	### and write it to the specified +file+. If +file+ is nil, the content will be
	### written to STDOUT instead.
	def do_download( uri, uuid, file )
		resource = @client.fetch( uuid ) or
			raise "No such resource #{uuid}"
			
		fh = get_writer_io( file )
		resource.export( fh )
		fh.close

		$stderr.puts "Fetched resource at %s." % [ uuid ]
	end


	### Get an IO object for reading from the specified +filename+. If +filename+ is 
	### +nil+, returns the IO for STDIN instead.
	def get_reader_io( filename=nil )
		return $defin unless filename
		return File.open( filename, File::RDONLY )
	end


	### Get an IO object for writing to the specified +filename+. If +filename+ is 
	### +nil+, returns the IO for STDOUT instead.
	def get_writer_io( filename=nil )
		return $stdout unless filename
		return File.open( filename, File::WRONLY|File::CREAT|File::TRUNC )
	end


	# Create an object to deduce mimetypes.
	def get_mime_analyzer
		unless @mime_analyzer
			begin
				require 'mahoro'
				$stderr.puts "Using Mahoro for MIME analysis"
				flags = Mahoro::SYMLINK|Mahoro::MIME
				@mime_analyzer = Mahoro.new( flags )
			rescue LoadError
			end
	
			unless @mime_analyzer
				begin
					require 'filemagic'
					$stderr.puts "Using Filemagic for MIME analysis"
					flags = FileMagic::MAGIC_SYMLINK|FileMagic::MAGIC_MIME
					@mime_analyzer = FileMagic.new( flags )
				rescue LoadError
				end
			end
	
			unless @mime_analyzer
				@mime_analyzer = Class.new do
					def file( ignored )
						return 'application/octet-stream'
					end
					def buffer( ignored )
						return 'application/octet-stream'
					end
				end.new
			end

		end
		
		return @mime_analyzer
	end


	### Try to deduce a mimetype from the first 2k of data read from the given +io+ and 
	### return it. The IO object will be rewound before returning.
	def get_mimetype( io )
		data = io.read( 2048 )
		io.rewind

		analyzer = get_mime_analyzer or
			raise "Ack. None of the strategies for deriving mimetype worked."

		return analyzer.buffer( data )
	end
end


if __FILE__ == $0
	$DEBUG = true
	progname = Pathname.new( $0 ).basename
	
	begin
		unless ARGV.length >= 2
			usage = <<-USAGE
			Usage:
				#{progname} THINGFISH_URL upload FILE
				#{progname} THINGFISH_URL check  UUID
				#{progname} THINGFISH_URL fetch  UUID FILE
				#{progname} THINGFISH_URL update UUID FILE
			USAGE
			usage.gsub!(/^\t{3}/, '').gsub!(/\t/, '  ')
			puts usage
			exit 1
		end
		client = ThingFish::CommandLineClient.new

		client.main( *ARGV )
	rescue => err
		$stderr.puts "ERROR: #{err.message}"
		$stderr.puts "  " + err.backtrace.join( "\n  " ) if $DEBUG
	end
end

# vim: set nosta noet ts=4 sw=4:
