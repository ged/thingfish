---
title: "Writing a ThingFish MetaStore"
layout: default
index: 6
filters:
  - erb
  - api
  - links
  - examples
  - textile
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

h3. What's a MetaStore?

A MetaStore is the component of ThingFish responsible for the tracking
and manipulation of resource metadata.  There can only be one
<?api ThingFish::MetaStore ?> installed for a running ThingFish server.

By default, ThingFish stores all metadata into memory.  This is nice
for testing and experimentation, but has some obvious drawbacks if you
care for the longevity of your data.  ThingFish is distributed with
a few alternative persistent metastores, which you can enable in the
@thingfish.conf@ file.

<?example { language: yaml, caption: "Installing the sequel MetaStore" } ?>
plugins:
    metastore:
        name: sequel
        sequel_connect: sqlite://///home/thingfish/metastore.db
<?end example?>

The Sequel plugin stores all ThingFish metadata using the
"Sequel":http://sequel.rubyforge.org/ ruby module, which is capable
of using a vast assortment of database backends.  The above example
specifies a "SQLite":http://www.sqlite.org/ file.  ThingFish already has
a number of MetaStore plugins, and it's likely that there is one that
fits the needs of your environment.  If that's not the case, or if you
just want to do something fancier, then you can write your own.  Here's
how.


h3. MetaStore Framework

<?example { language: ruby, caption: 'A fictional simple MetaStore plugin' } ?>
require 'thingfish'
require 'thingfish/metastore/simple'

class ThingFish::CarrierPigeonMetaStore < ThingFish::SimpleMetaStore

	### Create a new CarrierPigeonMetaStore
	def initialize( datadir=nil, spooldir=nil, options={} )
		super
	end

	### Mandatory APIs
	### ...

	### Optional APIs
	### ...
end
<?end example?>

|_. line number |_. what's it doing? |
| 2 | There are two types of ThingFish MetaStore: _simple_ and _advanced_.  Simple MetaStores are basic tuple spaces.  We'll talk more about advanced MetaStores later. |
| 4 | A simple MetaStore inherits from the <?api ThingFish::SimpleMetaStore ?> parent class.  The MetaStore name needs to match the filename it is stored in - in this case, the file would be called _carrierpigeon.rb_ and be stored in a _lib/metastore_ directory.  |
| 7 | MetaStores are instantiated with the globally configured data and spool directories.  It's up to the MetaStore author to use them -- there is no requirement to do so. |

h3. The Mandatory Interface

All <?api ThingFish::MetaStore ?> plugins must implement eighteen
methods for basic functionality within the ThingFish system.

Let's start with an example @#has_uuid?@ predicate.

<?example { language: ruby, caption: 'The #has_uuid method' } ?>
### MetaStore API: Returns +true+ if the given
### +uuid+ exists in the store.
def has_uuid?( uuid )
	return @metadata.key?( uuid.to_s )
end
<?end example?>

|_. line number |_. what's it doing? |
| 3 | @#has_uuid?@ is given a @uuid@ object. |
| 4 | Assuming your metadata is stored in a hash-like object, check if it's a valid key. |

@@metadata@ in this case is the magical instantiated backend for the
CarrierPigeonMetaStore, that happens to behave like a hash.  Your
MetaStore will most likely act differently, but let's show one more
simple case for illustrative purposes.

<?example { language: ruby, caption: 'The #has_property method' } ?>
### MetaStore API: Returns +true+ if the given +uuid+
### has a property +propname+.
def has_property?( uuid, propname )
	return @metadata[ uuid.to_s ].key?( propname.to_sym )
end
<?end example?>

|_. line number |_. what's it doing? |
| 3 | @#has_uuid?@ is given a @uuid@ object, and a @property@ string to lookup. |
| 4 | Continuing the hash-like object assumption, check for the existence of the @property@ for the given @uuid@ resource. |

All <?api ThingFish::MetaStore ?> objects implement the @:[]@ and @:[]=@
methods, internally using @get_property@ and @set_property@.  You can use
@@metastore[ uuid ][ 'rating' ]@ or @@metastore.get_property( uuid, 'rating' )@,
according to your personal tastes.  Metadata property keys
also have matching predicate methods, so you can ask questions like
@@metastore[ uuid ].has_rating?@.

The other required methods depend heavily on your storage backend.
Please reference the existing MetaStore plugins for specific
implementation examples!


<dl class="kvlist">
	<dt>@#set_property( uuid, property, value )@</dt>
	<dd class="description">
		Set the specified @property@ for the given @uuid@ to @value@.
	</dd>

	<dt>@#set_properties( uuid, hash )@</dt>
	<dd class="description">
		Set the properties associated with the given @uuid@ to those in the provided @hash@,
		eliminating any others already set.
	</dd>

	<dt>@#update_properties( uuid, hash )@</dt>
	<dd class="description">
		Merge the properties in the provided @hash@ with those associated with the given 
		@uuid@.
	</dd>

	<dt>@#get_property( uuid, property )@</dt>
	<dd class="description">
		Return the value of the specified @property@ for the given @uuid@, or @nil@ if it 
		doesn't exist.
	</dd>

	<dt>@#get_properties( uuid )@</dt>
	<dd class="description">
		Return the set of properties associated with the given @uuid@ as a hash keyed by property
		names as symbols.
	</dd>

	<dt>@#delete_property( uuid, property )@</dt>
	<dd class="description">
		Delete the specified @property@ for the given @uuid@.
	</dd>

	<dt>@#delete_properties( uuid, *properties )@</dt>
	<dd class="description">
		Delete all the properties in the @properties@ Array for the associated @uuid@.
	</dd>

	<dt>@#delete_resource( uuid )@</dt>
	<dd class="description">
		Delete all properties associated with the given @uuid@.
	</dd>

	<dt>@#get_all_property_keys@</dt>
	<dd class="description">
		Return an Array of all property keys in the store.
	</dd>

	<dt>@#get_all_property_values( key )@</dt>
	<dd class="description">
		Return a uniquified Array of all values in the metastore for the specified @key@.
	</dd>

	<dt>@#find_exact_uuids( key, value )@</dt>
	<dd class="description">
		Return an @Array@ of UUIDs whose metadata exactly matched the criteria
		specified by +key+ and +value+.
	</dd>

	<dt>@#find_matching_uuids( key, value )@</dt>
	<dd class="description">
		Return an array of uuids whose metadata matched the criteria
		specified by @key@ and @value@. This is a wildcard search.
	</dd>

	<dt>@#dump_store@</dt>
	<dd class="description">
		Returns the entire content of the MetaStore as a hash, keyed by uuid.
	</dd>

	<dt>@#load_store( hash )@</dt>
	<dd class="description">
		Replace the contents of the store with the given @hash@ of metadata, keyed 
		by UUID. The hash should be of the same form as that generated by #dump_store.
	</dd>

	<dt>@#each_resource {|uuid,hash| ... }@</dt>
	<dd class="description">
		Iterates over the store, yielding the @uuid@ and a @hash@ of associated properties
		for each resource in the store.
	</dd>

	<dt>@#clear@</dt>
	<dd class="description">
		Permanently purge all data contained in the MetaStore.
	</dd>
</dl>


h3. Optional Interfaces

h4. Startup Tasks

If your MetaStore needs to perform maintenance tasks when ThingFish
starts up, you can define an @#on_startup@ method.  Just like the
equivalent method in <?api ThingFish::FileStore ?>, this is called
during daemon initialization, after any effective user switches have
occurred.

h4. Performing Actions Atomically

Some MetaStore methods that perform multiple actions concurrently
should fail if there is an error in the middle of an update.  This
is a good idea for read-only actions as well, since clients could
be modifying metadata while another client is trying to read in a
consistent state.  If your backend has a concept of transactional
storage, you can implement a @#transaction@ method to wrap actions
safely within.

By default, it does nothing but yield the block passed to it.  Here's an
example from the Sequel MetaStore.

<?example { language: ruby, caption: 'Transactions in the Sequel MetaStore.' } ?>
### A metastore backend that stores metadata tuples in a database,
### accessed via the Sequel library.
class ThingFish::SequelMetaStore < ThingFish::SimpleMetaStore
	extend Forwardable

	### Create a new SequelMetaStore
	def initialize( datadir, spooldir, options={} )
		super
		@metadata = Sequel.sqlite
	end

	# Delegate transactions to the underlying Sequel object.
	def_delegators :@metadata, :transaction

	# ...

	### MetaStore API: Merge the provided +propshash+ into the properties associated with the
	### given +uuid+.
	def update_properties( uuid, propshash )
		self.transaction do
			propshash.each do | prop, val |
				self.set_property( uuid, prop, val )
			end
		end
	end

	# ...
end
<?end example?>

|_. line number |_. what's it doing? |
| 4 | Extend with the @Forwardable@ module, to obtain method delegations. |
| 9 | Create a Sequel-initialized, SQLite backend. |
| 13 | Sequel implements it's own @#transaction@ method internally: this MetaStore's @#transaction@ simply falls through to it. |
| 20 | MetaStore operations that should be atomic are wrapped within a transaction block.  If there is an error at any point, all of the previous modifications are reverted automatically. |

h3. Advanced MetaStores

All of the above is implemented using the <?api ThingFish::SimpleMetaStore ?>
class.  Work on an advanced MetaStore is in progress, starting with an
"RDF":http://www.w3.org/RDF/ backed store.

We're still in discussion about what kind of features an advanced
MetaStore will immediately provide, but we do know that they will be a
_triple_ space (instead of the _tuple_ space of the simple variety) and
will offer a superset of the Simple store's API.

They will also allow for:

* Strong data typing, which will grant the ability to perform optimized searches (such as date-range)
* Multiple values for a key (such as categorization or tagging per property)
* Native syntax support for searching (for the RDF store, we're thinking of allowing POST to /search in "sparql":http://www.w3.org/TR/rdf-sparql-query/ format)

As our advanced MetaStore nears completion and the API settles, we'll elaborate further on this section.

